v1.0 blockers
-------------
- Fleshed out JSON support
- Automatically adding named windows to the WINDOW clause
    - If it works, can remove Window method from Queries

Additional Features that don't break API
----------------------------------------
- WithLogFunc
- Query compiling + argument rebinding

WithLogFunc
type LogInfo struct {
    Query        string
    Args         []interface{}
    RowsFetched  int64
    TimeTaken    time.Duration
    RowsAffected int64
    LastInsertID int64 // mysql only
}
WithLogFunc(fn).Select(x, y, z)
where fn is of type func(loginfo LogInfo)

Queries can be precompiled to avoid the paying the price of string serialization over and over
    - Clauses can be added
    - Clauses can be removed
    - Clauses can be replaced (all or nothing, you can't modify just part of a clause)
    - This could be achieved by noting down the index where the each clause begins and ends
        i.e. adding clause == inserting a string after where the previous clause ends
        removing clause == deleting the substring from start index to end index
        replacing clause == deleting substring and reinserting a new string
        The index of where the clause args begin and end need to be noted down too
    - Let users insert dummy placeholder arguments marked with a string name, then they can rebind those arguments later for that string name
q := Select(tbl.col1, tbl.col2).From(tbl).Where(tbl.col1.Eq(sq.Placeholder("to_be_added_later"))).Compile()
q.Bind("to_be_added_later", someVar)
q.SelectRowx(user.RowMapper()).Fetch(db)
