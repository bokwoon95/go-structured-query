package main

import (
	"database/sql"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"unicode"

	"github.com/spf13/cobra"
)

// Go Types
const (
	GoTypeInterface    = "interface{}"
	GoTypeBool         = "bool"
	GoTypeInt          = "int"
	GoTypeFloat64      = "float64"
	GoTypeString       = "string"
	GoTypeTime         = "time.Time"
	GoTypeBoolSlice    = "[]bool"
	GoTypeIntSlice     = "[]int"
	GoTypeFloat64Slice = "[]float64"
	GoTypeStringSlice  = "[]string"
	GoTypeTimeSlice    = "[]time.Time"
	GoTypeByteSlice    = "[]byte"
)

var functionsCmd = &cobra.Command{
	Use:   "functions",
	Short: "Generate functions from the database",
	RunE:  functionsRun,
}

var functionsTemplate = `// Code generated by 'sqgen-postgres functions'; DO NOT EDIT.
package {{$.PackageName}}

import (
	{{- range $_, $import := $.Imports}}
	{{$import}}
	{{- end}}
)
{{- range $_, $function := $.Functions}}
{{template "function_struct_definition" $function}}
{{template "function_constructor" $function}}
{{template "function_as" $function}}
{{- end}}

{{- define "function_struct_definition"}}
{{- with $function := .}}
// {{$function.StructName.Export}} references the {{$function.Schema}}.{{$function.Name}} function.
type {{$function.StructName.Export}} struct {
	*sq.FunctionInfo
	{{- range $_, $result := $function.Results}}
	{{$result.Name.Export}} {{$result.FieldType}}
	{{- end}}
}
{{- end}}
{{- end}}

{{- define "function_constructor"}}
{{- with $function := .}}
// {{$function.Constructor.Export}} creates an instance of the {{$function.Schema}}.{{$function.Name}} function.
func {{$function.Constructor.Export}}(
	{{- range $_, $arg := $function.Arguments}}
	{{$arg.Name}} {{$arg.GoType}},
	{{- end}}
	) {{$function.StructName.Export}} {
	return {{$function.Constructor.Export}}_({{range $i, $arg := $function.Arguments}}{{if not $i}}{{$arg.Name}}{{else}}, {{$arg.Name}}{{end}}{{end}})
}

// {{$function.Constructor.Export}}_ creates an instance of the {{$function.Schema}}.{{$function.Name}} function.
func {{$function.Constructor.Export}}_(
	{{- range $_, $arg := $function.Arguments}}
	{{$arg.Name}} interface{},
	{{- end}}
	) {{$function.StructName.Export}} {
	f := {{$function.StructName.Export}}{FunctionInfo: &sq.FunctionInfo{
		Schema: "{{$function.Schema}}",
		Name: "{{$function.Name}}",
		Arguments: []interface{}{{"{"}}{{range $i, $arg := $function.Arguments}}{{if not $i}}{{$arg.Name}}{{else}}, {{$arg.Name}}{{end}}{{end}}{{"}"}},
	},}
	{{- range $_, $result := $function.Results}}
	f.{{$result.Name.Export}} = {{$result.Constructor}}("{{$result.Name}}", f.FunctionInfo)
	{{- end}}
	return f
}
{{- end}}
{{- end}}

{{- define "function_as"}}
{{- with $function := .}}
// As modifies the alias of the underlying function.
func (f {{$function.StructName.Export}}) As(alias string) {{$function.StructName.Export}} {
	f.FunctionInfo.Alias = alias
	return f
}
{{- end}}
{{- end}}`

// Function contains metadata for a plpgsql function.
type Function struct {
	Schema       string
	Name         string
	RawResults   string
	RawArguments string
	StructName   String
	Constructor  String
	Results      []FunctionField
	Arguments    []FunctionField
}

// FunctionField represents a Function that is also a Field.
type FunctionField struct {
	RawField    string
	Name        String
	FieldType   string
	GoType      string
	Constructor string
}

func init() {
	sqgenCmd.AddCommand(functionsCmd)
	// Initialise flags
	functionsCmd.Flags().String("database", "", "(required) Database URL")
	functionsCmd.Flags().String("directory", filepath.Join(currdir, "tables"), "(optional) Directory to place the generated file. Can be absolute or relative filepath")
	functionsCmd.Flags().Bool("dryrun", false, "(optional) Print the list of functions to be generated without generating the file")
	functionsCmd.Flags().String("file", "functions.go", "(optional) Name of the file to be generated. If file already exists, -overwrite flag must be specified to overwrite the file")
	functionsCmd.Flags().Bool("overwrite", false, "(optional) Overwrite any files that already exist")
	functionsCmd.Flags().String("pkg", "tables", "(optional) Package name of the file to be generated")
	functionsCmd.Flags().String("schemas", "public", "(optional) A comma separated list of database schemas that you want to generate functions for. Please don't include any spaces")
	// Mark required flags
	cobra.MarkFlagRequired(functionsCmd.LocalFlags(), "database")
}

func functionsRun(cmd *cobra.Command, args []string) error {
	// Prep flag values
	database, _ := cmd.Flags().GetString("database")
	directory, _ := cmd.Flags().GetString("directory")
	dryrun, _ := cmd.Flags().GetBool("dryrun")
	file, _ := cmd.Flags().GetString("file")
	overwrite, _ := cmd.Flags().GetBool("overwrite")
	pkg, _ := cmd.Flags().GetString("pkg")
	schemasStr, _ := cmd.Flags().GetString("schemas")
	schemas := strings.FieldsFunc(schemasStr, func(r rune) bool { return r == ',' || unicode.IsSpace(r) })
	if !strings.HasSuffix(file, ".go") {
		file = file + ".go"
	}
	asboluteFilePath := filepath.Join(directory, file)
	if _, err := os.Stat(asboluteFilePath); err == nil && !overwrite {
		return fmt.Errorf("Specified file %s already exists. If you wish to overwrite it, provide the --overwrite flag", asboluteFilePath)
	}

	// Setup database
	db, err := sql.Open("postgres", database)
	if err != nil {
		return wrap(err)
	}
	err = db.Ping()
	if err != nil {
		return fmt.Errorf("Could not ping the database, is the database reachable via " + database + "? " + err.Error())
	}

	// Get list of functions from database
	functions, err := getFunctions(db, database, schemas)
	if err != nil {
		return wrap(err)
	}
	if dryrun {
		for _, function := range functions {
			fmt.Println(function)
		}
		return nil
	}

	// Write list of functions into file
	err = writeFunctionsToFile(functions, directory, file, pkg)
	if err != nil {
		return wrap(err)
	}
	fmt.Println("[RESULT] ", strconv.Itoa(len(functions)), "functions written into", filepath.Join(directory, file))
	return nil
}

func getFunctions(db *sql.DB, databaseURL string, schemas []string) ([]Function, error) {
	// replacePlaceholders will replace question mark placeholders with dollar
	// placeholders e.g. ?, ?, ? -> $1, $2, $3 etc
	replacePlaceholders := func(query string) string {
		buf := &strings.Builder{}
		var i int
		for pos := strings.Index(query, "?"); pos >= 0; pos = strings.Index(query, "?") {
			i++
			buf.WriteString(query[:pos] + "$" + strconv.Itoa(i))
			query = query[pos+1:]
		}
		buf.WriteString(query)
		return buf.String()
	}

	// Prepare the query and args
	query := replacePlaceholders(
		"SELECT n.nspname, p.proname" +
			", pg_catalog.pg_get_function_result(p.oid) AS result" +
			", pg_catalog.pg_get_function_identity_arguments(p.oid) as arguments" +
			" FROM pg_catalog.pg_proc AS p" +
			" LEFT JOIN pg_catalog.pg_namespace AS n ON n.oid = p.pronamespace" +
			" WHERE n.nspname IN (?" + strings.Repeat(", ?", len(schemas)-1) + ") AND p.prokind = 'f'" +
			" ORDER BY n.nspname <> 'public', n.nspname, p.proname",
		// sql custom ordering: https://stackoverflow.com/q/4088532
	)
	args := make([]interface{}, len(schemas))
	for i := range schemas {
		args[i] = schemas[i]
	}

	// Query the database and aggregate the results into a []Function slice
	rows, err := db.Query(query, args...)
	fmt.Println(query, args)
	if err != nil {
		return nil, wrap(err)
	}
	defer rows.Close()
	var functions []Function
	for rows.Next() {
		var functionSchema, functionName, functionsResults, functionArguments string
		err := rows.Scan(&functionSchema, &functionName, &functionsResults, &functionArguments)
		if err != nil {
			return functions, err
		}
		functionSchema = strings.ReplaceAll(functionSchema, " ", "_")
		functionName = strings.ReplaceAll(functionName, " ", "_")
		function := Function{
			Schema:       functionSchema,
			Name:         functionName,
			RawResults:   functionsResults,
			RawArguments: functionArguments,
		}
		functions = append(functions, function)
	}

	// Do postprocessing on the functions to fill in the struct names,
	// constructors, etc
	functions = processFunctions(functions)
	return functions, nil
}

func processFunctions(functions []Function) []Function {
	var functionNames = make(map[string]int)          // how many times function name appears
	var qualifiedFunctionNames = make(map[string]int) // how many times schema qualified function name appears
	var functionNumber = make(map[string]int)         // which overloaded function iteration are we at
	var outputFunctions []Function
	for i := range functions {
		functionNames[functions[i].Name]++
		qualifiedFunctionNames[functions[i].Schema+"."+functions[i].Name]++
	}
NEXT_FUNCTION:
	for i := range functions {
		functions[i].StructName = "FUNCTION_"
		schema := functions[i].Schema
		name := functions[i].Name
		qualifiedName := functions[i].Schema + "." + functions[i].Name
		overloaded := false
		// Add schema prefix to struct name and constructor if more than one
		// function share same name
		if functionNames[name] > 1 {
			functions[i].StructName += String(strings.ToUpper(schema + "__"))
			functions[i].Constructor += String(strings.ToUpper(schema + "__"))
			if qualifiedFunctionNames[qualifiedName] > 1 {
				overloaded = true
			}
		}
		functions[i].StructName += String(strings.ToUpper(name))
		functions[i].Constructor += String(strings.ToUpper(name))
		// If function is overloaded, append an incrementing number to each
		// function to un-overload it
		if overloaded {
			functionNumber[qualifiedName]++
			functions[i].StructName += String(strconv.Itoa(functionNumber[qualifiedName]))
			functions[i].Constructor += String(strconv.Itoa(functionNumber[qualifiedName]))
		}

		// Function Arguments
		switch {
		case functions[i].RawArguments == "":
			break
		default:
			rawFields := strings.Split(functions[i].RawArguments, ",")
			for j := range rawFields {
				field := extractNameAndType(rawFields[j])
				rawField := strings.ToUpper(field.RawField)
				if strings.HasPrefix(rawField, "VARIADIC ") {
					fmt.Printf("Skipping %s.%s because VARIADIC arguments are not supported '%s'\n", functions[i].Schema, functions[i].Name, functions[i].RawArguments)
					continue NEXT_FUNCTION
				}
				if strings.HasPrefix(rawField, "IN ") || strings.HasPrefix(rawField, "OUT ") {
					fmt.Printf("Skipping %s.%s because INOUT arguments are not supported '%s'\n", functions[i].Schema, functions[i].Name, functions[i].RawArguments)
					continue NEXT_FUNCTION
				}
				if field.FieldType == "" {
					fmt.Printf("Skipping %s.%s because user-defined type '%s' is not supported\n", functions[i].Schema, functions[i].Name, field.RawField)
					continue NEXT_FUNCTION
				}
				if field.Name == "" {
					field.Name = "_arg" + String(strconv.Itoa(j+1)) // give unnamed arguments a name
				}
				functions[i].Arguments = append(functions[i].Arguments, field)
			}
		}

		// Function Results
		rawResults := functions[i].RawResults
		switch {
		case rawResults == "void":
			break
		case strings.HasPrefix(rawResults, "TABLE(") && strings.HasSuffix(rawResults, ")"):
			rawResults = rawResults[6 : len(rawResults)-1] // remove 'TABLE (' prefix and ')' suffix
			rawFields := strings.Split(rawResults, ",")
			for j := range rawFields {
				field := extractNameAndType(rawFields[j])
				if field.FieldType == "" {
					fmt.Printf("Skipping %s.%s because return type '%s' is not supported\n", functions[i].Schema, functions[i].Name, field.RawField)
					continue NEXT_FUNCTION
				}
				if field.Name == "" {
					field.Name = "Result" + String(strconv.Itoa(j+1)) // give unnamed return values a name
				}
				functions[i].Results = append(functions[i].Results, field)
			}
		default:
			if rawResults == "trigger" {
				fmt.Printf("Skipping %s.%s because it is a trigger function\n", functions[i].Schema, functions[i].Name)
				continue NEXT_FUNCTION
			}
			if strings.HasPrefix(rawResults, "SETOF ") {
				rawResults = rawResults[6:] // remove 'SETOF ' prefix
			}
			field := extractNameAndType(strings.TrimSpace(functions[i].RawResults))
			if field.FieldType == "" {
				fmt.Printf("Skipping %s.%s because return type '%s' is not supported\n", functions[i].Schema, functions[i].Name, functions[i].RawResults)
				continue NEXT_FUNCTION
			}
			field.Name = "Result"
			functions[i].Results = []FunctionField{field}
		}
		outputFunctions = append(outputFunctions, functions[i])
	}
	return outputFunctions
}

func extractNameAndType(rawField string) FunctionField {
	var field FunctionField
	field.RawField = strings.TrimSpace(rawField)
	if matches := regexp.
		MustCompile(`boolean` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		// fmt.Println(rawField, matches)
		// Boolean
		field.Name = String(strings.TrimSpace(rawField[:len(rawField)-len(matches[0])]))
		if matches[1] == "[]" {
			field.FieldType = FieldTypeArray
			field.GoType = GoTypeBoolSlice
			field.Constructor = FieldConstructorArray
		} else {
			field.FieldType = FieldTypeBoolean
			field.GoType = GoTypeBool
			field.Constructor = FieldConstructorBoolean
		}

	} else if matches := regexp.
		MustCompile(`json` + `(?:b)?` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		// fmt.Println(rawField, matches)
		// JSON
		field.Name = String(strings.TrimSpace(rawField[:len(rawField)-len(matches[0])]))
		if matches[1] == "[]" {
			field.FieldType = FieldTypeArray
			field.GoType = GoTypeInterface
			field.Constructor = FieldConstructorArray
		} else {
			field.FieldType = FieldTypeJSON
			field.GoType = GoTypeInterface
			field.Constructor = FieldConstructorJSON
		}

	} else if matches := regexp.
		MustCompile(`(?:` + `smallint` +
			`|` + `oid` +
			`|` + `integer` +
			`|` + `bigint` +
			`|` + `smallserial` +
			`|` + `serial` +
			`|` + `bigserial` + `)` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		// fmt.Println(rawField, matches)
		// Integer
		field.Name = String(strings.TrimSpace(rawField[:len(rawField)-len(matches[0])]))
		if matches[1] == "[]" {
			field.FieldType = FieldTypeArray
			field.GoType = GoTypeIntSlice
			field.Constructor = FieldConstructorArray
		} else {
			field.FieldType = FieldTypeNumber
			field.GoType = GoTypeInt
			field.Constructor = FieldConstructorNumber
		}

	} else if matches := regexp.
		MustCompile(`(?:` + `decimal` +
			`|` + `numeric` +
			`|` + `real` +
			`|` + `double precision` + `)` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		// fmt.Println(rawField, matches)
		// Float
		field.Name = String(strings.TrimSpace(rawField[:len(rawField)-len(matches[0])]))
		if matches[1] == "[]" {
			field.FieldType = FieldTypeArray
			field.GoType = GoTypeFloat64Slice
			field.Constructor = FieldConstructorArray
		} else {
			field.FieldType = FieldTypeNumber
			field.GoType = GoTypeFloat64
			field.Constructor = FieldConstructorNumber
		}

	} else if matches := regexp.
		MustCompile(`(?:` + `text` +
			`|` + `name` +
			`|` + `char` + `(?:\(\d+\))?` +
			`|` + `character` + `(?:\(\d+\))?` +
			`|` + `varchar` + `(?:\(\d+\))?` +
			`|` + `character varying` + `(?:\(\d+\))?` + `)` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		// fmt.Println(rawField, matches)
		// String
		field.Name = String(strings.TrimSpace(rawField[:len(rawField)-len(matches[0])]))
		if matches[1] == "[]" {
			field.FieldType = FieldTypeArray
			field.GoType = GoTypeStringSlice
			field.Constructor = FieldConstructorArray
		} else {
			field.FieldType = FieldTypeString
			field.GoType = GoTypeString
			field.Constructor = FieldConstructorString
		}

	} else if matches := regexp.
		MustCompile(`(?:` + `date` +
			`|` + `(?:time|timestamp)` +
			`(?: \(\d+\))?` +
			`(?: without time zone| with time zone)?` + `)` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		// fmt.Println(rawField, matches)
		// Time
		field.Name = String(strings.TrimSpace(rawField[:len(rawField)-len(matches[0])]))
		if matches[1] == "[]" {
			// Do nothing
		} else {
			field.FieldType = FieldTypeTime
			field.GoType = GoTypeTime
			field.Constructor = FieldConstructorTime
		}

	} else if matches := regexp.
		MustCompile(`bytea` +
			`(\[\])?` +
			`$`).
		FindStringSubmatch(field.RawField); len(matches) == 2 {
		if matches[1] == "[]" {
			// Do nothing
		} else {
			field.FieldType = FieldTypeBinary
			field.GoType = GoTypeByteSlice
			field.Constructor = FieldConstructorBinary
		}
	}
	return field
}

// writeFunctionsToFile will write the functions into a file specified by
// filepath.Join(directory, file).
func writeFunctionsToFile(functions []Function, directory, file, packageName string) error {
	err := os.MkdirAll(directory, 0755)
	if err != nil {
		return fmt.Errorf("Could not create directory %s: %w", directory, err)
	}
	filename := filepath.Join(directory, file)
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()
	t, err := template.New("").Parse(functionsTemplate)
	if err != nil {
		return err
	}
	data := struct {
		PackageName string
		Imports     []string
		Functions   []Function
	}{
		PackageName: packageName,
		Imports: []string{
			`sq "github.com/bokwoon95/go-structured-query/postgres"`,
		},
		Functions: functions,
	}
	err = t.Execute(f, data)
	if err != nil {
		return err
	}
	if _, err := exec.LookPath("goimports"); err == nil {
		_ = exec.Command("goimports", "-w", filename).Run()
	} else if _, err := exec.LookPath("gofmt"); err == nil {
		_ = exec.Command("gofmt", "-w", filename).Run()
	}
	return nil
}

// String implements the fmt.Stringer interface.
func (f Function) String() string {
	var output string
	if f.Constructor != "" && f.StructName != "" {
		output += fmt.Sprintf("%s.%s => func %s() %s\n", f.Schema, f.Name, f.Constructor, f.StructName)
	} else {
		output += fmt.Sprintf("%s.%s\n", f.Schema, f.Name)
	}
	output += fmt.Sprintf("    Arguments\n")
	for _, field := range f.Arguments {
		if field.Constructor != "" && field.GoType != "" {
			output += fmt.Sprintf("        %s: %s\n", field.Name, field.GoType)
		} else {
			output += fmt.Sprintf("        %s\n", field.RawField)
		}
	}
	output += fmt.Sprintf("    Results\n")
	for _, field := range f.Results {
		if field.Constructor != "" && field.FieldType != "" {
			output += fmt.Sprintf("        %s: %s\n", field.Name, field.FieldType)
		} else {
			output += fmt.Sprintf("        %s\n", field.RawField)
		}
	}
	return output
}
